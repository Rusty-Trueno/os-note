# 进程与线程

1. 进程的状态：
![进程的状态](进程的状态.png)

2. 进程控制表：
![进程控制表](进程控制表.png)

3. 中断执行步骤:
![中断执行步骤](中断执行步骤.png)

4. 进程VS线程:
![进程VS线程](进程VS线程.png)

5. 每个线程都拥有自己的堆栈，即堆栈帧，
线程栈帧中存放了被调用但是还没从中返回的过程的局部变量，
以及过程调用完成后使用的返回地址。
![线程自己的堆栈](线程自己的堆栈.png)

6. 用户级线程包VS内核管理的线程包：
在内核管理下的线程，如果一个线程阻塞了，内核根据其选择，
可以运行同一个进程中的另一个线程，或者运行另一个进程中的线程。
而在用户级线程中，运行时系统始终运行自己进程中的线程，
直到内核剥夺了该进程的CPU为止。（用户级，先进程，后线程；
内核级，由内核统一管理线程，线程是CPU调度的最小单位）。
但是，内核级线程的创建和删除需要陷入到系统调用，代价比较大。
![线程管理](线程管理.png)

7. 进程间通信：
 - 避免竞争需要满足的条件：
 ![避免竞争的四个条件](避免竞争的四个条件.png)
 
 - 严格轮换法：这种方法会导致线程被处于非临界区的线程阻塞
 ![严格轮换法](严格轮换法.png)
 ![线程被处于非临界区的线程阻塞](线程被处于非临界区的线程阻塞.png)
 
 - Peterson解法：注意图中框起来的，
 如果线程0和线程1同时想进入临界区，同时调用enter_region,
 则，数组的全部位置（0,1）均为true，但是公共变量turn只能
 是相对后面的线程对应的值。比如，当前turn为0，则线程0会进行
 忙等待，而线程1则可以进入临界区，当线程1离开临界区，调用leave_region
 后，interested[1]被置为false，此时，线程0就跳出循环，进入临界区。
 这样就可以保证， 线程只会被进入临界区的线程阻塞。
 ![Peterson解法](Peterson解法.png)
 
 - 优先级反转：
 ![优先级反转](优先级反转.png)
 
 - 生产者消费者问题（有界缓冲区问题）：
 ![使用信号量解决生产者消费者问题](使用信号量解决生产者消费者问题.png)
 
 
 

